#!/bin/bash
#
NAME="cstpkg"
CONFIGDIR="/etc/${NAME}.d"
LOCALCONFIGDIR="${HOME}/.${NAME}"
LIBDIR="/usr/lib/cstpkg"
#LIBDIR="/home/marko/Documents/projects/bash/cstpkg/lib"

hooksfile="PKGBUILD.func" # consist of only functions (build,prepare,check,package)
tmpfile="PKGBUILD.tmp" 
backupfile="PKGBUILD.original"

# use colordiff if it's available
[[ $(type -p colordiff) ]] && DIFFCMD="colordiff -ub" || DIFFCMD="diff -ub"

# define colors
R="$(tput bold)$(tput setaf 1)"
G="$(tput bold)$(tput setaf 2)"
B="$(tput bold)$(tput setaf 4)"
Y="$(tput bold)$(tput setaf 3)"
W="$(tput bold)$(tput setaf 7)"
w="$(tput setaf 7)"
N="$(tput sgr0)"

info(){
	local msgtype="$1"
	case $msgtype in
		-m ) printf "%b\n" " ${G}:::${N} $2" 	;; 
		-e ) printf "%b\n" " ${R}:E:${N} $2"	;; 
		-E ) printf "%b\n" "  ${R}*${N}  Fatal error ${2}, Exiting..."; exit $3	;; 
		-w ) printf "%b\n" " ${Y}:W:${N} $2" 	;; 
		-d ) printf "%b\n" " ${G}:D:${N} $2" 	;; 
		-a ) printf "%b\n" "  -> $2" ;; 
	esac
}

# dont need this but I created it because maybe more idea will come
include(){
	local modules="$@"
	
	for module in ${modules[@]} ; do
		[[ -e ${LIBDIR}/${module}.bash ]] && \
			source "${LIBDIR}/${module}.bash" || notfound+="${module} "
	done

	if [[ ! -z $notfound ]]; then
		for lib in ${notfound}; do
			info -w "Lib '${W}${lib}${N}' doesn't exist"
		done
		exit 14 # E_CODE terminate if lib not found
	fi

	return 0
}

do_patch(){
	local scriptfile=${1} diff=${2}
	
	info -m "Patching ${scriptfile} with ${diff}"	
		patch --quiet "${scriptfile}" < ${diff} || \
			(info -e "Something wen't wrong while patching ${scriptfile}" && return 127)
	
	return 0
}

validate_and_copy_file(){
	local file=${1}

	# checking exsistance of specified file
	if [[ ! -f ${CONFIGDIR}/${package}/${file} ]]; then
		info -w "File ${file} doesn't exist! Using orginal PKGBUILD functions"
		return 127
	else
		cp ${CONFIGDIR}/${package}/${file} "./" || return 127
		return 0
	fi	
}

clean(){
	local destroy="${hooksfile} ${tmpfile} ${tmpfile}.orig hooks_* \
		*.cstpkg update-vars* PKGBUILD.upstream PKGBUILD.${package}"
	
	info -m "Removing work files bellow:"
	for i in ${destroy[@]}; do 
		[[ -f $i ]] && info -a "$i" && rm $i
	done
}

error_handling(){
	local ret=$?; shift
	
	case $ret in
			0 ) echo 0    ;; # no errors
		125 ) echo 125  ;; # errors from libs
		127 ) echo 127  ;; # errors from function
		255 ) echo 255  ;; # errors from main
			* ) echo $ret ;; # any other error
	esac
}

modify_file(){
	local configfile=$1 originalscriptfile=$2 scriptfile=$3

	# NOTE: DO I NEED THIS, WILL I ALLOW THIS KIND OF METHOD?
	# if the customize file is executable, run it, then we're done.
	if [ -x "${configfile}" ]; then
		info -m "${configfile} is executable, so treating it as a script instead of config"
		"${configfile}" "${originalscriptfile}" "${scriptfile}" && return 0 || exit 1
	fi
	grep "^%" ${configfile} |
	while read -r action context pattern; do
		case ${action} in
			%config )
					include savedconfig
					restore_config "${context}" || return #E_CODE=125
				;;
			%update-vars )
					include downloader
					local git=0 fallback=0
					
					# git or bzr or svn ...
					[[ ${package} =~ \-git ]] && git=1
					
					info -m "updating PKGBUILD vars from usptream"
					
					# PKGBUILD must exist in $CONFIGDIR/$package. If not it will fallback to upstream ver
					# and with him we can update var with new one from upstream servers
					validate_and_copy_file "PKGBUILD.${package}"  || fallback=1
					
					# fetch PKGBUILD 
					getpkgbuild "${context}" "./PKGBUILD.upstream"
					# create diff between ./PKGBUILD and PKGBUILD upstream
					diff -ub <(sed -n "1,/^[a-z].*()/p" ./PKGBUILD | head -n -1 ) \
					<(sed -n "1,/^[a-z].*()/p" ./PKGBUILD.upstream | head -n -1) \
					> ./update-vars.diff
					
					# finaly patch PKGBUILD
					do_patch "${scriptfile}" "./update-vars.diff" || return
					
					# if PKGBUILD.${package} doesn't exist ignore all this bellow: otherwise 
					# remove all function from PKGBUILD.tmp as we will replace them
					# with our function from /etc PKGBUILD.audit
					# also add removed function from PKGBUILD.${package}
					if ! (( $fallback )); then 
						sed -i "/^[a-zA-Z].*() {/,/^}\n/d" "${scriptfile}"
						sed -n "/^[a-zA-Z].*() {/,/^}\n/p" "./PKGBUILD.${package}" >> ${scriptfile}
					fi
				;;
			# TODO: add strict nonstrict 	
			* )
				info -e "There is no such action: ${action}" 1>&2
				exit 255
				;;
		esac
	done

	# immediately exit from program if error occour
	E_CODE=$(error_handling)
	[[ $E_CODE != 0 ]] && return $E_CODE

	grep --invert-match "\(^#\|^$\|^%\)" ${configfile} |
	while IFS='#' read -r action context pattern value ovalue; do
		case ${action} in
			replace)
					#value="${value//\'}"
					case ${context} in
						global ) 
							info -m "replaces '${pattern}' with '${value}' in ${context}"
							case ${pattern} in
								makedepends|optdepends|depends)
									pattern="${pattern}[<>=]*\(: \|\)[a-z0-9.{$}\-]*"
									sed -i "/^${context}=/,/)$/ s|${pattern}|${value}|g" "${scriptfile}" ;;
								* )
									sed -i "s|${pattern}|${value}|g" "${scriptfile}" ;;
							esac ;;
						function ) 
							#	NOTE:	use#file#hook#function name#	
							info -m "diff hook '${pattern}' from ${hooksfile}"
							
							validate_and_copy_file "${hooksfile}" || return

							#<(sed -n "/${value}/,/^}/p" "./PKGBUILD.hooks" ) \
							diff -ub <(sed -n "/${pattern}/,/^}/p" ${scriptfile}) \
							<(sed -n "/${pattern}/,/^}/p" "./${hooksfile}" ) \
							> ./hooks_${pattern}.diff
							 
							info -m "Patching ${scriptfile} with ./hook_${pattern}.diff"	
							patch --quiet "${scriptfile}" < ./hooks_${pattern}.diff || \
								(info -e "Something wen't wrong while patching ${scriptfile}" && return 127)
							;;
						inside )
							info -m "replaces '${pattern}' with '${value}' in ${context}"
							# NOTE: replace inside specific function
							sed -i "/^${pattern}() {/,/^}$/ s|${value}|${ovalue}|g" "${scriptfile}" ;; 	
						* )	
							info -m "replaces '${pattern}' with '${value}' in ${context}"
							sed -i "s|${pattern}|${value}|g" "${scriptfile}" ;;
					esac ;;
			
			remove)
					# remove#context#pattern
					case ${context} in 
						global )
							info -m "removes '${pattern//\'/}' from '${context}'"
							sed -i "s|${pattern}||g" "${scriptfile}"
							;;
						function ) 
							info -m "removes '${pattern//\'/}' from '${scriptfile}'"
							sed -i "/${pattern}/,/^}/d" "${scriptfile}"
						;;
						inside )
							value="$(echo ${value} | sed 's|/|\\/|g')"
							info -m "removes inside '${pattern//\'/}' value '${value}'"
							sed -i "/^${pattern}/,/^}$/ {/${value}/d}" "${scriptfile}" 
							;; 	
						* ) 
							info -m "removes '${pattern//\'/}' from '${context}'"
							# if makedepends/optdepends/depends
							#[[ ${context} =~ depends$ ]] && \
							#pattern="${pattern}[<>=]*\(: \|\)[a-z0-9.{$}\-]*" 
							# junk the quotes too
							sed -i "/${context}/,/)$/ s|[[:blank:]]*['\"]*${pattern}['\"]*||g" "${scriptfile}" 	
						;;
				esac ;;
			insert ) 
					case ${context} in 
						function ) 
								[[ ! -f ${CONFIGDIR}/${package}/PKGBUILD.${pattern} ]] && \
								echo "File 'PKGBUILD.${pattern}' doesn't exist in '$CONFIGDIR'" && exit 1 
							;;
						inside )
						;;
					esac ;;
					
			*)
				info -e "unknown action '${action}'" 1>&2
				exit 255
				;;
		esac
	done
	
	E_CODE=$(error_handling)
	[[ $E_CODE != 0 ]] && return $E_CODE
	
	(( $VERBOSE )) && \
		${DIFFCMD} "${originalscriptfile}" "${scriptfile}"
	
	return 0
}

################################################
VERBOSE=0 
PATCH=0
MODIFY=0
E_CODE=0
while [ "$#" -ne "0" ]; do
	case $1 in
		-h|--help)
			usage
			exit 0
			;;
		-m|--modify) # show diff stdout 
			MODIFY=1
			;;
		--vimdiff| -v)
			[[ $(type -p vim) ]] && DIFFCMD="vim -d" && VERBOSE=1 \
				|| info -w 'vim was not found' 1>&2
			;;
		--verbose ) 
			VERBOSE=1 ;;
	esac
	shift
done

if [ ! -r ./PKGBUILD ]; then
	info -e 'PKGBUILD not found' 1>&2
	exit 255
fi

# use eval instead of creating a temp file to get pkgname etc
eval $(grep -E '^[[:blank:]]*_?(pkg.*|git.*|name)=' ./PKGBUILD | grep -Ev 'log|\describe')

# copy for modification
cp ./PKGBUILD ./${backupfile}
cp ./PKGBUILD ./${tmpfile} # .work u .tmp

for package in "${pkgname[@]}"
do
	
	# local user prefs take priority
	[[ -d "${LOCALCONFIGDIR}/${package}" ]] && \
		CONFIGDIR=${LOCALCONFIGDIR}
	
	# package doesnt exist in CONFIGDIR/
	[[ ! -d ${CONFIGDIR}/${package} ]] && continue
	
	if [[ -f ${CONFIGDIR}/${package}/${package}.cstpkg ]]; then
		cp "${CONFIGDIR}/${package}/${package}.cstpkg" "./"
	else
		info -e "${package}.cstpkg doesn't exist in $CONFIGDIR/${package}"
		exit 255
	fi	
	
	# 1 configfile 2 originalscriptfile 3 scriptfile
	modify_file "./${package}.cstpkg" "./PKGBUILD" "./${tmpfile}" || \
		info -E "code $E_CODE" "$E_CODE"

	(( ${MODIFY} )) && \
		mv ./PKGBUILD.tmp ./PKGBUILD && \
		clean

done
exit 0
